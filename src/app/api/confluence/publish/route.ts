import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const payload = await request.json();
    const { jd, extracted, org, templates, loop, ashbyJobId, jobTitle } = payload;

    if (!extracted || !loop) {
      return NextResponse.json({ 
        error: 'Extracted data and interview loop are required' 
      }, { status: 400 });
    }

    // Generate page content
    const pageContent = generateIntakePageContent({
      jd, extracted, org, templates, loop, ashbyJobId, jobTitle
    });

    // Use jobTitle if provided, otherwise use extracted function
    const pageTitle = generatePageTitle(extracted, jobTitle);
    const pageResult = await publishToConfluence(pageTitle, pageContent);

    return NextResponse.json({
      pageId: pageResult.pageId,
      url: pageResult.url,
      title: pageTitle
    });

  } catch (error) {
    console.error('Confluence publish error:', error);
    return NextResponse.json(
      { error: 'Failed to publish to Confluence', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

function generatePageTitle(extracted: any, jobTitle?: string): string {
  const level = extracted.level || 'Mid';
  // Use jobTitle if provided, otherwise use extracted function
  const role = jobTitle || extracted.function || 'Role';
  const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  
  return `INTAKE – ${level} ${role} – ${timestamp}`;
}

function generateIntakePageContent(data: any): string {
  const { jd, extracted, org, templates, loop, ashbyJobId, jobTitle } = data;
  
  const content = `# ${generatePageTitle(extracted, jobTitle)}

## 📄 Job Description

${jd || 'No job description provided'}

---

## 📋 Job Requirements Analysis

### Level & Function
- **Level**: ${extracted.level}
- **Function**: ${extracted.function}

### Must-Have Skills
${extracted.mustHaves.map((skill: string) => `- ${skill}`).join('\n')}

### Nice-to-Have Skills  
${extracted.niceToHaves.map((skill: string) => `- ${skill}`).join('\n')}

### Core Competencies
${extracted.competencies.map((comp: any) => `- **${comp.name}**: ${comp.rationale}`).join('\n')}

## 👥 Organization Context

### Team Structure
- **Hiring Manager**: ${org?.manager || 'TBD'}
- **Team Members**: ${org?.team?.join(', ') || 'TBD'}
- **Cross-functional Partners**: ${org?.crossFunc?.join(', ') || 'None'}

## 🎯 Proposed Interview Loop

**Total Time**: ${loop.totalMins} minutes

### Interview Stages
${loop.stages.map((stage: any, i: number) => `
${i + 1}. **${stage.name}** (${stage.durationMins}m)
   - **Intent**: ${stage.intent}
   - **Signals**: ${stage.signals.join(', ')}
   - **Suggested Interviewer**: ${stage.interviewerHints?.join(', ') || 'TBD'}
`).join('')}

${loop.risks.length > 0 ? `
### ⚠️ Identified Risks
${loop.risks.map((risk: string) => `- ${risk}`).join('\n')}
` : ''}

## 📄 Template Matches

${templates?.map((template: any) => `
- **${template.title}** (${template.source}) - ${Math.round(template.score * 100)}% match
  ${template.url ? `  - [View Template](${template.url})` : ''}
  ${template.notes ? `  - ${template.notes}` : ''}
`).join('') || 'No templates matched'}

## 🔗 Links & References

${ashbyJobId ? `- **Ashby Job ID**: ${ashbyJobId}` : '- **Ashby Job ID**: Not provided'}
- **Generated**: ${new Date().toISOString()}
- **Tool**: SmartIntake AI

## 📊 Raw Data (JSON)

\`\`\`json
${JSON.stringify({ extracted, org, templates, loop }, null, 2)}
\`\`\`

---

*This interview intake was generated by SmartIntake AI. Review and adjust as needed before implementing.*`;

  return content;
}

// Real Confluence API integration
async function publishToConfluence(title: string, content: string) {
  const baseUrl = process.env.CONFLUENCE_BASE_URL;
  const email = process.env.CONFLUENCE_EMAIL;
  const apiToken = process.env.CONFLUENCE_API_TOKEN;
  const parentId = process.env.CONFLUENCE_INTAKE_PARENT_ID;

  if (!baseUrl || !email || !apiToken) {
    throw new Error('Confluence credentials not configured');
  }

  // Convert markdown to Confluence storage format (basic conversion)
  const storageFormat = convertMarkdownToConfluenceStorage(content);

  // Create the page
  const response = await fetch(`${baseUrl}/rest/api/content`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Basic ${Buffer.from(`${email}:${apiToken}`).toString('base64')}`
    },
    body: JSON.stringify({
      type: 'page',
      title: title,
      space: {
        key: 'IRT' // Interview & Recruiting Team space
      },
      ...(parentId && {
        ancestors: [{
          id: parentId
        }]
      }),
      body: {
        storage: {
          value: storageFormat,
          representation: 'storage'
        }
      },
      metadata: {
        labels: [
          { prefix: 'global', name: 'hiring-intake' },
          { prefix: 'global', name: 'smartintake-ai' },
          { prefix: 'global', name: 'interview-plan' }
        ]
      }
    })
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('Confluence API error:', errorText);
    throw new Error(`Confluence API error: ${response.status} ${response.statusText}`);
  }

  const page = await response.json();
  
  // Construct proper URL - baseUrl already includes /wiki
  // page._links.webui starts with /spaces/...
  const pageUrl = `${baseUrl}${page._links.webui}`;
  
  console.log('✅ Published to Confluence:', { 
    title, 
    pageId: page.id,
    url: pageUrl
  });
  
  return {
    pageId: page.id,
    url: pageUrl
  };
}

// Convert basic markdown to Confluence storage format
function convertMarkdownToConfluenceStorage(markdown: string): string {
  let html = markdown
    // Headers
    .replace(/^### (.*?)$/gm, '<h3>$1</h3>')
    .replace(/^## (.*?)$/gm, '<h2>$1</h2>')
    .replace(/^# (.*?)$/gm, '<h1>$1</h1>')
    // Bold
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    // Italic  
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    // Lists
    .replace(/^- (.*?)$/gm, '<li>$1</li>')
    // Links
    .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>')
    // Code blocks
    .replace(/```json\n([\s\S]*?)```/g, '<ac:structured-macro ac:name="code"><ac:parameter ac:name="language">json</ac:parameter><ac:plain-text-body><![CDATA[$1]]></ac:plain-text-body></ac:structured-macro>')
    .replace(/```(.*?)\n([\s\S]*?)```/g, '<ac:structured-macro ac:name="code"><ac:parameter ac:name="language">$1</ac:parameter><ac:plain-text-body><![CDATA[$2]]></ac:plain-text-body></ac:structured-macro>')
    // Inline code
    .replace(/`(.*?)`/g, '<code>$1</code>')
    // Line breaks
    .replace(/\n\n/g, '<br/><br/>')
    .replace(/\n/g, '<br/>');

  // Wrap list items in ul tags
  html = html.replace(/(<li>[\s\S]*?<\/li>\s*)+/g, '<ul>$&</ul>');

  return html;
}








